# 分布式协调

## Zookeeper
### 介绍
大规模分布式应用需要不同形式的协调程序，配置是一种协调的最基本的形式。对于实现互斥访问临界资源，锁是一个强大的协调原语。
协调的一种方式是对于不同的协调需求开发不同服务。
设计协调服务时，从服务器端移除了与特定原语相关的部分，实现一个协调内核，提供 API 给应用开发人员实现自己的原语。
设计 ZooKeeper API，移除了阻塞原语，例如锁。阻塞原语对于一个协调服务会引起其它问题，速度较慢或者故障的客户端会对速度较快的客户端产生负面的影响

为了保证更新操作满足线性化，Zookeeper实现了基于领导者的原子广播协议 Zab。ZooKeeper 应用的主要负载是读操作，所以需要保证读吞吐量的可扩展。在 ZooKeeper 中，服务器在本地处理读操作，并不需要使用 Zab。

ZooKeeper 使用 watch 机制使得客户端不需要直接管理客户端缓存。使用这一机制，对于一个给定的数据对象，客户端可以监视到更新，当有更新的时候收到通知消息。watch机制由Follower实现而不是Leader

### Zookeeper服务

#### 数据模型
#### ZNode
Zookeeper 给客户端提供了数据节点集（znodes）抽象表示，数据节点集以层次化命名空间的形式组织，类似于文件系统的组织方式。znodes 是 Zookeeper 层次化结构中提供给客户端通过 API 操作的数据对象。Zookeeper提供两种类型的结点

1. 临时结点
   临时结点依赖于结点创建的会话，会话结束会被自动删除，不可以拥有子节点
   
2. 普通结点
   不依赖于会话，由客户端显式的创建和删除。
   
Znode是用来映射客户端应用的抽象表示，存放用于协调的元数据信息，主要包括以下三部分：

1. 结点状态信息：包括版本号、更改时间、访问控制列表(ACL)等

2. 结点的内容数据：主要用于协调调度

3. Znode的子结点

Zookeeper可以创建顺序结点，在结点名字结尾处添加一个自增的id

#### Zxid(ZooKeeper Transaction Id)

所有对Zookeeper状态的改变都会产生一个全局有序的Zxid，用来标识事件发生的先后顺序。

每个ZNode维护两个Zxid:

1. cZxid: Znode创建时的Zxid

2. mZxid: Znode最近修改的Zxid

Zxid是一个64位的数字, 高32位表示Zookeeper集群leader, 低32位表示逻辑顺序


#### 客户端Zookeeper API

create(path, data, flags)：使用 path 名称创建一个 znode 节点，保存 data，返回新创建的 znode 名称。 flags 用于创建普通或者临时节点，也可以设置顺序标识。

delete(path, version)： 删除指定 path 和 version 的 znode 节点。

exists(path, watch)： 如果指定 path 的 znode 存在则返回真，如果不存在则返回假。watch 标识用于在 znode 上设置监视器。

getData(path, watch)： 返回数据和元数据，如版本信息。watch 标识与 exists() 的 watch 标识一样，但如果 znode 不存在则不会设置监视器。

setData(path, data, version)： 根据 path 和 version 将数据写入到 znode。

getChildren(path, watch)： 返回 znode 所有子节点的名称集合。

sync(path)： 在操作开始时，等待所有挂起的更新操作发送到客户端连接的服务器。path 当前未使用。

每次的更新都是对给定版本的更新，如果实际版本号与期望的版本号不一致，更新操作就会失败。

#### watch机制
Watch 触发是一次性的，当触发器通知了一次状态变化后消失，不会通知状态的再次变化。
Zookeeper与客户端之间通过 Tcp Socket 进行通信，保证会将监视的Znode变化主动通知客户端。

Zookeeper 支持三种类型的watch:

1. exists: 被监视的Znode 创建、删除、数据改变时被触发

2. getData: 被监视的Znode 删除、数据改变时被触发

3. getChildren: 被监视的Znode 删除、创建子节点、删除子节点时被触发


#### Zookeeper保证
Zookeeper对于操作的执行顺序提供两个基本保证：

1. 线性化写

   所有更新Zookeeper状态的请求都是都是序列化的并且遵循优先级

2. FIFO的客户端请求顺序
  
   对于一个客户端的所有请求，都会按客户端发送的顺序执行

值得注意的是，对于读请求，是顺序一致性的，可能会读到过时的数据，保证最终一致性

**顺序一致性和线性一致性的区别**：

线性一致性：是一种强一致性，强调全局的顺序

顺序一致性：强调偏序，只保证每个结点的执行操作是有序的，不保证结点间的顺序。


### Zookeeper实现
Zookeeper通过复制 ZooKeeper数据(用于协调的元数据)给每一个服务器提供了高可用的服务。在收到来自客户端的请求时，如果该请求(写请求)需要服务器间的协调，那么需要使用原子广播来保证强一致性，最后服务器提交请求给在所有服务之间复制的ZooKeeper数据库。对于读请求，一个服务读取本地数据库的状态生成请求的响应消息。复制的数据库是一个包含整个数据树的内存数据库，为了保证可以恢复，在写入内存数据库之前，强制写入磁盘。

![image](https://user-images.githubusercontent.com/79254572/181870175-ea9318c0-4972-41ce-95e0-11e05c71d89d.png)


#### 请求处理器
1. 读请求
   直接在本地数据库读取状态和数据生成响应消息
   
2. 写请求
   重定向给Leader，通过Leader进行原子广播维护数据和状态的一致性

由于消息层是原子的，可以保证本地副本不会出现差错。当Leader收到写请求，会计算系统写入后的状态并且将其转化为捕获新状态的事务。

#### 原子广播Zab
所有更新 ZooKeeper 状态的请求被转发到Leader，Leader执行请求并且通过原子广播协议 Zab 广播变更信息，当成功发送状态变更后，返回给客户端发送响应。Zab 默认使用简单的多数服从原则，当超过半数服务器正常时，Zab 和 ZooKeeper 就会正常工作。
为了获得高吞吐量，ZooKeeper 尽量保持请求处理管道是满的，在处理管道不同部分会有成千上万的请求，因为状态变化依赖前面的状态变化，所以Zab 提供强一致性保证发送请求顺序广播，所有前领导者的变更请求会在其自己状态变更之前广播。
因为使用幂等的事务，只要按顺序发送，多次发送也是可以接受的。事实上，ZooKeeper 要求 Zab 至少重新发送上次快照开始后发送的所有消息

#### 复制到数据库
每个副本都在内存中有一份 ZooKeeper 状态的拷贝，当 ZooKeeper 从故障中恢复时，需要恢复其内部状态。ZooKeeper 使用周期性的快照，每次**只需要重新发送从快照开始**的消息，只要顺序写入状态变更消息，由于是幂等的，可以进行两次变更，最终保证与宕机前的服务状态一致。

#### C/S交互
服务器处理写请求时，也会将更新相关的通知发送出去并清空。服务器按顺序处理写请求，并且不会同时并发地处理其它的写或读请求，这保证了通知的严格一致。服务器在本地处理通知，仅仅客户连接的服务器跟踪触发通知消息

读请求在每个**服务器本地**处理。每个读请求都会被处理，并使用对应于服务器看到的最后一个事务的 zxid 标记。zxid 定义了读请求相对于写请求的**部分顺序**。通过在本地处理读请求，可以获得非常高的读性能，因为是本地服务器的内存操作，没有磁盘操作和共识协议。这一设计对以读为主的工作负载可以满足高性能的目标

一个不足之处是读请求不能保证读请求的优先级顺序，读操作可能读取到旧的状态信息，对于那些需要优先级顺序的应用，需要使用 sync 实现

ZooKeeper 服务器以先进先出的顺序处理请求。如果客户端连接到新的服务，新服务器通过检查客户端的最后一个 zxid 和其自己的 zxid，保证 ZooKeeper 数据视图至少比客户端新，客户端保证能够找到其它有新数据视图的服务器，因为这些变更已经被复制到大多数的服务器。

ZooKeeper 使用超时来检测客户端会话失败。如果在会话超时时间内没有其他服务器从客户端会话接收到任何消息，则领导者确定客户端发生了故障。
为了防止会话超时，ZooKeeper 客户端会在会话空闲 s/3 ms 后发送心跳，如果在 2s/3 ms 内没有收到服务器的消息，则切换到新的服务器，其中 s 是会话超时时间


### Zookeeper应用


